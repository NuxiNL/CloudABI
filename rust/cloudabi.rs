// Copyright (c) 2016 Nuxi (https://nuxi.nl/) and contributors.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// This file is automatically generated. Do not edit.
//
// Source: https://github.com/NuxiNL/cloudabi

//! **PLEASE NOTE: This entire crate including this
//! documentation is automatically generated from
//! [`cloudabi.txt`](https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt)**
//!
//! # Nuxi CloudABI
//!
//! CloudABI is what you get if you take POSIX, add capability-based
//! security, and remove everything that's incompatible with that. The
//! result is a minimal ABI consisting of only 49 syscalls.
//!
//! CloudABI doesn't have its own kernel, but instead is implemented in existing
//! kernels: FreeBSD has CloudABI support for x86-64 and arm64, and [a patch-set
//! for NetBSD](https://github.com/NuxiNL/netbsd) and [a patch-set for
//! Linux](https://github.com/NuxiNL/linux) are available as well. This means that
//! CloudABI binaries can be executed on different operating systems, without any
//! modification.
//!
//! ## Capability-Based Security
//!
//! Capability-based security means that processes can only perform
//! actions that have no global impact. Processes cannot open files by
//! their absolute path, cannot open network connections, and cannot
//! observe global system state such as the process table.
//!
//! The capabilities of a process are fully determined by its set of open
//! file descriptors (fds). For example, files can only be opened if the
//! process already has a file descriptor to a directory the file is in.
//!
//! Unlike in POSIX, where processes are normally started with file
//! descriptors 0, 1, and 2 reserved for standard input, output, and
//! error, CloudABI does not reserve any file descriptor numbers for
//! specific purposes.
//!
//! In CloudABI, a process depends on its parent process to launch it with
//! the right set of resources, since the process will not be able to open
//! any new resources. For example, a simple static web server would need
//! to be started with a file descriptor to a [TCP
//! listener](https://github.com/NuxiNL/flower), and a file descriptor to
//! the directory for which to serve files. The web server will then be
//! unable to do anything other than reading files in that directory, and
//! process incoming network connections.
//!
//! So, unknown CloudABI binaries can safely be executed without the need
//! for containers, virtual machines, or other sandboxing technologies.
//!
//! Watch [Ed Schouten's Talk at
//! 32C3](https://www.youtube.com/watch?v=3N29vrPoDv8) for more
//! information about what capability-based security for UNIX means.
//!
//! ## Cloudlibc
//!
//! [Cloudlibc](https://github.com/NuxiNL/cloudlibc) is an implementation
//! of the C standard library, without all CloudABI-incompatible
//! functions. For example, Cloudlibc does not have `printf`, but does
//! have `fprintf`. It does not have `open`, but does have `openat`.
//!
//! ## CloudABI-Ports
//!
//! [CloudABI-Ports](https://github.com/NuxiNL/cloudabi-ports) is a
//! collection of ports of commonly used libraries and applications to
//! CloudABI. It contains software such as `zlib`, `libpng`, `boost`,
//! `memcached`, and much more. The software is patched to not depend on
//! any global state, such as files in `/etc` or `/dev`, using `open()`,
//! etc.
//!
//! ## Using CloudABI
//!
//! Instructions for using CloudABI (including kernel modules/patches,
//! toolchain, and ports) are available for several operating systems:
//!
//! - [Arch Linux](https://nuxi.nl/cloudabi/archlinux/)
//! - [Debian, Ubuntu, and other Debian derivatives](https://nuxi.nl/cloudabi/debian/)
//! - [FreeBSD, PC-BSD and DragonFly BSD](https://nuxi.nl/cloudabi/freebsd/)
//! - [Mac OS X](https://nuxi.nl/cloudabi/mac/)
//! - [NetBSD](https://nuxi.nl/cloudabi/netbsd/)
//!
//! ## Specification of the ABI
//!
//! The entire ABI is specified in a a file called
//! [`cloudabi.txt`](https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt),
//! from which all
//! [headers](https://github.com/NuxiNL/cloudabi/tree/master/headers)
//! and documentation (including the one you're reading now) is generated.

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#[macro_use]
extern crate bitflags;

/// File or memory access pattern advisory information.
#[repr(u8)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub enum advice {
  /// The application expects that it will not access the
  /// specified data in the near future.
  DONTNEED   = 1,
  /// The application expects to access the specified data
  /// once and then not reuse it thereafter.
  NOREUSE    = 2,
  /// The application has no advice to give on its behavior
  /// with respect to the specified data.
  NORMAL     = 3,
  /// The application expects to access the specified data
  /// in a random order.
  RANDOM     = 4,
  /// The application expects to access the specified data
  /// sequentially from lower offsets to higher offsets.
  SEQUENTIAL = 5,
  /// The application expects to access the specified data
  /// in the near future.
  WILLNEED   = 6,
  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,
}

/// Enumeration describing the kind of value stored in `auxv`.
#[repr(u32)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub enum auxtype {
  /// Base address of the binary argument data provided to
  /// `proc_exec`.
  ARGDATA      = 256,
  /// Length of the binary argument data provided to
  /// `proc_exec`.
  ARGDATALEN   = 257,
  /// Base address at which the executable is placed in
  /// memory.
  BASE         =   7,
  /// Base address of a buffer of random data that may be
  /// used for non-cryptographic purposes, for example as a
  /// canary for stack smashing protection.
  CANARY       = 258,
  /// Length of a buffer of random data that may be used
  /// for non-cryptographic purposes, for example as a
  /// canary for stack smashing protection.
  CANARYLEN    = 259,
  /// Number of CPUs that the system this process is running
  /// on has.
  NCPUS        = 260,
  /// Terminator of the auxiliary vector.
  NULL         =   0,
  /// Smallest memory object size for which individual
  /// memory protection controls can be configured.
  PAGESZ       =   6,
  /// Address of the first ELF program header of the
  /// executable.
  PHDR         =   3,
  /// Number of ELF program headers of the executable.
  PHNUM        =   4,
  /// Identifier of the process.
  ///
  /// This environment does not provide any simple numerical
  /// process identifiers, for the reason that these are not
  /// useful in distributed contexts. Instead, processes are
  /// identified by a UUID.
  ///
  /// This record should point to sixteen bytes of binary
  /// data, containing a version 4 UUID (fully random).
  PID          = 263,
  /// Address of the ELF header of the vDSO.
  ///
  /// The vDSO is a shared library that is mapped in the
  /// address space of the process. It provides entry points
  /// for every system call supported by the environment,
  /// all having a corresponding symbol that is prefixed
  /// with `cloudabi_sys_`. System calls should be invoked
  /// through these entry points.
  ///
  /// The first advantage of letting processes call into a
  /// vDSO to perform system calls instead of raising
  /// hardware traps is that it allows for easy emulation of
  /// executables on top of existing operating systems. The
  /// second advantage is that in cases where an operating
  /// system provides native support for CloudABI executables,
  /// it may still implement partial userspace
  /// implementations of these system calls to improve
  /// performance (e.g., `clock_time_get`). It also provides
  /// a more dynamic way of adding, removing or replacing
  /// system calls.
  SYSINFO_EHDR = 262,
  /// Thread ID of the initial thread of the process.
  TID          = 261,
  #[doc(hidden)] _NonExhaustive = -1 as isize as u32,
}

/// Identifiers for clocks.
#[repr(u32)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub enum clockid {
  /// The system-wide monotonic clock, which is defined as a
  /// clock measuring real time, whose value cannot be
  /// adjusted and which cannot have negative clock jumps.
  ///
  /// The epoch of this clock is undefined. The absolute
  /// time value of this clock therefore has no meaning.
  MONOTONIC          = 1,
  /// The CPU-time clock associated with the current
  /// process.
  PROCESS_CPUTIME_ID = 2,
  /// The system-wide clock measuring real time. Time value
  /// zero corresponds with 1970-01-01T00:00:00Z.
  REALTIME           = 3,
  /// The CPU-time clock associated with the current thread.
  THREAD_CPUTIME_ID  = 4,
  #[doc(hidden)] _NonExhaustive = -1 as isize as u32,
}

/// A userspace condition variable.
#[repr(C)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct condvar(pub u32);
/// The condition variable is in its initial state. There
/// are no threads waiting to be woken up. If the
/// condition variable has any other value, the kernel
/// must be called to wake up any sleeping threads.
pub const CONDVAR_HAS_NO_WAITERS: condvar = condvar(0);

/// Identifier for a device containing a file system. Can be used
/// in combination with `inode` to uniquely identify a file on the
/// local system.
#[repr(C)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct device(pub u64);

/// A reference to the offset of a directory entry.
#[repr(C)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct dircookie(pub u64);
/// Permanent reference to the first directory entry
/// within a directory.
pub const DIRCOOKIE_START: dircookie = dircookie(0);

/// Error codes returned by system calls.
///
/// Not all of these error codes are returned by the system calls
/// provided by this environment, but are either used in userspace
/// exclusively or merely provided for alignment with POSIX.
#[repr(u16)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub enum errno {
  /// Argument list too long.
  TOOBIG         =  1,
  /// Permission denied.
  ACCES          =  2,
  /// Address in use.
  ADDRINUSE      =  3,
  /// Address not available.
  ADDRNOTAVAIL   =  4,
  /// Address family not supported.
  AFNOSUPPORT    =  5,
  /// Resource unavailable, or operation would block.
  AGAIN          =  6,
  /// Connection already in progress.
  ALREADY        =  7,
  /// Bad file descriptor.
  BADF           =  8,
  /// Bad message.
  BADMSG         =  9,
  /// Device or resource busy.
  BUSY           = 10,
  /// Operation canceled.
  CANCELED       = 11,
  /// No child processes.
  CHILD          = 12,
  /// Connection aborted.
  CONNABORTED    = 13,
  /// Connection refused.
  CONNREFUSED    = 14,
  /// Connection reset.
  CONNRESET      = 15,
  /// Resource deadlock would occur.
  DEADLK         = 16,
  /// Destination address required.
  DESTADDRREQ    = 17,
  /// Mathematics argument out of domain of function.
  DOM            = 18,
  /// Reserved.
  DQUOT          = 19,
  /// File exists.
  EXIST          = 20,
  /// Bad address.
  FAULT          = 21,
  /// File too large.
  FBIG           = 22,
  /// Host is unreachable.
  HOSTUNREACH    = 23,
  /// Identifier removed.
  IDRM           = 24,
  /// Illegal byte sequence.
  ILSEQ          = 25,
  /// Operation in progress.
  INPROGRESS     = 26,
  /// Interrupted function.
  INTR           = 27,
  /// Invalid argument.
  INVAL          = 28,
  /// I/O error.
  IO             = 29,
  /// Socket is connected.
  ISCONN         = 30,
  /// Is a directory.
  ISDIR          = 31,
  /// Too many levels of symbolic links.
  LOOP           = 32,
  /// File descriptor value too large.
  MFILE          = 33,
  /// Too many links.
  MLINK          = 34,
  /// Message too large.
  MSGSIZE        = 35,
  /// Reserved.
  MULTIHOP       = 36,
  /// Filename too long.
  NAMETOOLONG    = 37,
  /// Network is down.
  NETDOWN        = 38,
  /// Connection aborted by network.
  NETRESET       = 39,
  /// Network unreachable.
  NETUNREACH     = 40,
  /// Too many files open in system.
  NFILE          = 41,
  /// No buffer space available.
  NOBUFS         = 42,
  /// No such device.
  NODEV          = 43,
  /// No such file or directory.
  NOENT          = 44,
  /// Executable file format error.
  NOEXEC         = 45,
  /// No locks available.
  NOLCK          = 46,
  /// Reserved.
  NOLINK         = 47,
  /// Not enough space.
  NOMEM          = 48,
  /// No message of the desired type.
  NOMSG          = 49,
  /// Protocol not available.
  NOPROTOOPT     = 50,
  /// No space left on device.
  NOSPC          = 51,
  /// Function not supported.
  NOSYS          = 52,
  /// The socket is not connected.
  NOTCONN        = 53,
  /// Not a directory or a symbolic link to a directory.
  NOTDIR         = 54,
  /// Directory not empty.
  NOTEMPTY       = 55,
  /// State not recoverable.
  NOTRECOVERABLE = 56,
  /// Not a socket.
  NOTSOCK        = 57,
  /// Not supported, or operation not supported on socket.
  NOTSUP         = 58,
  /// Inappropriate I/O control operation.
  NOTTY          = 59,
  /// No such device or address.
  NXIO           = 60,
  /// Value too large to be stored in data type.
  OVERFLOW       = 61,
  /// Previous owner died.
  OWNERDEAD      = 62,
  /// Operation not permitted.
  PERM           = 63,
  /// Broken pipe.
  PIPE           = 64,
  /// Protocol error.
  PROTO          = 65,
  /// Protocol not supported.
  PROTONOSUPPORT = 66,
  /// Protocol wrong type for socket.
  PROTOTYPE      = 67,
  /// Result too large.
  RANGE          = 68,
  /// Read-only file system.
  ROFS           = 69,
  /// Invalid seek.
  SPIPE          = 70,
  /// No such process.
  SRCH           = 71,
  /// Reserved.
  STALE          = 72,
  /// Connection timed out.
  TIMEDOUT       = 73,
  /// Text file busy.
  TXTBSY         = 74,
  /// Cross-device link.
  XDEV           = 75,
  /// Extension: Capabilities insufficient.
  NOTCAPABLE     = 76,
  #[doc(hidden)] _NonExhaustive = -1 as isize as u16,
}

bitflags! {
  /// The state of the file descriptor subscribed to with
  /// `eventtype.fd_read` or `eventtype.fd_write`.
  pub struct eventrwflags: u16 {
    /// The peer of this socket has closed or disconnected.
    const HANGUP = 0x0001;
  }
}

/// Type of a subscription to an event or its occurrence.
#[repr(u8)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub enum eventtype {
  /// The time value of clock `subscription.clock.clock_id`
  /// has reached timestamp `subscription.clock.timeout`.
  CLOCK          = 1,
  /// Condition variable `subscription.condvar.condvar` has
  /// been woken up and `subscription.condvar.lock` has been
  /// acquired for writing.
  CONDVAR        = 2,
  /// File descriptor `subscription.fd_readwrite.fd` has
  /// data available for reading. This event always triggers
  /// for regular files.
  FD_READ        = 3,
  /// File descriptor `subscription.fd_readwrite.fd` has
  /// capacity available for writing. This event always
  /// triggers for regular files.
  FD_WRITE       = 4,
  /// Lock `subscription.lock.lock` has been acquired for
  /// reading.
  LOCK_RDLOCK    = 5,
  /// Lock `subscription.lock.lock` has been acquired for
  /// writing.
  LOCK_WRLOCK    = 6,
  /// The process associated with process descriptor
  /// `subscription.proc_terminate.fd` has terminated.
  PROC_TERMINATE = 7,
  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,
}

/// Exit code generated by a process when exiting.
pub type exitcode = u32;

/// A file descriptor number.
///
/// Unlike on POSIX-compliant systems, none of the file descriptor
/// numbers are reserved for a purpose (e.g., stdin, stdout,
/// stderr). Operating systems are not required to allocate new
/// file descriptors in ascending order.
#[repr(C)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct fd(pub u32);
/// Returned to the child process by `proc_fork`.
pub const PROCESS_CHILD: fd = fd(0xffffffff);
/// Passed to `mem_map` when creating a mapping to
/// anonymous memory.
pub const MAP_ANON_FD  : fd = fd(0xffffffff);

bitflags! {
  /// File descriptor flags.
  pub struct fdflags: u16 {
    /// Append mode: Data written to the file is always
    /// appended to the file's end.
    const APPEND   = 0x0001;
    /// Write according to synchronized I/O data integrity
    /// completion. Only the data stored in the file is
    /// synchronized.
    const DSYNC    = 0x0002;
    /// Non-blocking mode.
    const NONBLOCK = 0x0004;
    /// Synchronized read I/O operations.
    const RSYNC    = 0x0008;
    /// Write according to synchronized I/O file integrity
    /// completion. In addition to synchronizing the data
    /// stored in the file, the system may also synchronously
    /// update the file's metadata.
    const SYNC     = 0x0010;
  }
}

bitflags! {
  /// Which file descriptor attributes to adjust.
  pub struct fdsflags: u16 {
    /// Adjust the file descriptor flags stored in
    /// `fdstat.fs_flags`.
    const FLAGS  = 0x0001;
    /// Restrict the rights of the file descriptor to the
    /// rights stored in `fdstat.fs_rights_base` and
    /// `fdstat.fs_rights_inheriting`.
    const RIGHTS = 0x0002;
  }
}

/// Relative offset within a file.
pub type filedelta = i64;

/// Non-negative file size or length of a region within a file.
pub type filesize = u64;

/// The type of a file descriptor or file.
#[repr(u8)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub enum filetype {
  /// The type of the file descriptor or file is unknown or
  /// is different from any of the other types specified.
  UNKNOWN          =   0,
  /// The file descriptor or file refers to a block device
  /// inode.
  BLOCK_DEVICE     =  16,
  /// The file descriptor or file refers to a character
  /// device inode.
  CHARACTER_DEVICE =  17,
  /// The file descriptor or file refers to a directory
  /// inode.
  DIRECTORY        =  32,
  /// The file descriptor refers to a process handle.
  PROCESS          =  80,
  /// The file descriptor or file refers to a regular file
  /// inode.
  REGULAR_FILE     =  96,
  /// The file descriptor refers to a shared memory object.
  SHARED_MEMORY    = 112,
  /// The file descriptor or file refers to a datagram
  /// socket.
  SOCKET_DGRAM     = 128,
  /// The file descriptor or file refers to a byte-stream
  /// socket.
  SOCKET_STREAM    = 130,
  /// The file refers to a symbolic link inode.
  SYMBOLIC_LINK    = 144,
  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,
}

bitflags! {
  /// Which file attributes to adjust.
  pub struct fsflags: u16 {
    /// Adjust the last data access timestamp to the value
    /// stored in `filestat.st_atim`.
    const ATIM     = 0x0001;
    /// Adjust the last data access timestamp to the time
    /// of clock `clockid.realtime`.
    const ATIM_NOW = 0x0002;
    /// Adjust the last data modification timestamp to the
    /// value stored in `filestat.st_mtim`.
    const MTIM     = 0x0004;
    /// Adjust the last data modification timestamp to the
    /// time of clock `clockid.realtime`.
    const MTIM_NOW = 0x0008;
    /// Truncate or extend the file to the size stored in
    /// `filestat.st_size`.
    const SIZE     = 0x0010;
  }
}

/// File serial number that is unique within its file system.
#[repr(C)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct inode(pub u64);

/// Number of hard links to an inode.
pub type linkcount = u32;

/// A userspace read-recursive readers-writer lock, similar to a
/// Linux futex or a FreeBSD umtx.
#[repr(C)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct lock(pub u32);
/// Value indicating that the lock is in its initial
/// unlocked state.
pub const LOCK_UNLOCKED      : lock = lock(0x00000000);
/// Bitmask indicating that the lock is write-locked. If
/// set, the lower 30 bits of the lock contain the
/// identifier of the thread that owns the write lock.
/// Otherwise, the lower 30 bits of the lock contain the
/// number of acquired read locks.
pub const LOCK_WRLOCKED      : lock = lock(0x40000000);
/// Bitmask indicating that the lock is either read locked
/// or write locked, and that one or more threads have
/// their execution suspended, waiting to acquire the
/// lock. The last owner of the lock must call the
/// kernel to unlock.
///
/// When the lock is acquired for reading and this bit is
/// set, it means that one or more threads are attempting
/// to acquire this lock for writing. In that case, other
/// threads should only acquire additional read locks if
/// suspending execution would cause a deadlock. It is
/// preferred to suspend execution, as this prevents
/// starvation of writers.
pub const LOCK_KERNEL_MANAGED: lock = lock(0x80000000);
/// Value indicating that the lock is in an incorrect
/// state. A lock cannot be in its initial unlocked state,
/// while also managed by the kernel.
pub const LOCK_BOGUS         : lock = lock(0x80000000);

bitflags! {
  /// Flags determining the method of how paths are resolved.
  pub struct lookupflags: u32 {
    /// As long as the resolved path corresponds to a symbolic
    /// link, it is expanded.
    const SYMLINK_FOLLOW = 0x00000001;
  }
}

bitflags! {
  /// Memory mapping flags.
  pub struct mflags: u8 {
    /// Instead of mapping the contents of the file provided,
    /// create a mapping to anonymous memory. The file
    /// descriptor argument must be set to `fd.map_anon_fd`,
    /// and the offset must be set to zero.
    const ANON    = 0x01;
    /// Require that the mapping is performed at the base
    /// address provided.
    const FIXED   = 0x02;
    /// Changes are private.
    const PRIVATE = 0x04;
    /// Changes are shared.
    const SHARED  = 0x08;
  }
}

bitflags! {
  /// Memory page protection options.
  ///
  /// This implementation enforces the W^X property: Pages cannot be
  /// mapped for execution while also mapped for writing.
  pub struct mprot: u8 {
    /// Page can be executed.
    const EXEC  = 0x01;
    /// Page can be written.
    const WRITE = 0x02;
    /// Page can be read.
    const READ  = 0x04;
  }
}

bitflags! {
  /// Methods of synchronizing memory with physical storage.
  pub struct msflags: u8 {
    /// Perform asynchronous writes.
    const ASYNC      = 0x01;
    /// Invalidate cached data.
    const INVALIDATE = 0x02;
    /// Perform synchronous writes.
    const SYNC       = 0x04;
  }
}

/// Specifies the number of threads sleeping on a condition
/// variable that should be woken up.
pub type nthreads = u32;

bitflags! {
  /// Open flags used by `file_open`.
  pub struct oflags: u16 {
    /// Create file if it does not exist.
    const CREAT     = 0x0001;
    /// Fail if not a directory.
    const DIRECTORY = 0x0002;
    /// Fail if file already exists.
    const EXCL      = 0x0004;
    /// Truncate file to size 0.
    const TRUNC     = 0x0008;
  }
}

bitflags! {
  /// Flags provided to `sock_recv`.
  pub struct riflags: u16 {
    /// Returns the message without removing it from the
    /// socket's receive queue.
    const PEEK    = 0x0004;
    /// On byte-stream sockets, block until the full amount
    /// of data can be returned.
    const WAITALL = 0x0010;
  }
}

bitflags! {
  /// File descriptor rights, determining which actions may be
  /// performed.
  pub struct rights: u64 {
    /// The right to invoke `fd_datasync`.
    ///
    /// If `rights.file_open` is set, includes the right to
    /// invoke `file_open` with `fdflags.dsync`.
    const FD_DATASYNC           = 0x0000000000000001;
    /// The right to invoke `fd_read` and `sock_recv`.
    ///
    /// If `rights.mem_map` is set, includes the right to
    /// invoke `mem_map` with memory protection option
    /// `mprot.read`.
    ///
    /// If `rights.fd_seek` is set, includes the right to invoke
    /// `fd_pread`.
    const FD_READ               = 0x0000000000000002;
    /// The right to invoke `fd_seek`. This flag implies
    /// `rights.fd_tell`.
    const FD_SEEK               = 0x0000000000000004;
    /// The right to invoke `fd_stat_put` with
    /// `fdsflags.flags`.
    const FD_STAT_PUT_FLAGS     = 0x0000000000000008;
    /// The right to invoke `fd_sync`.
    ///
    /// If `rights.file_open` is set, includes the right to
    /// invoke `file_open` with `fdflags.rsync` and
    /// `fdflags.dsync`.
    const FD_SYNC               = 0x0000000000000010;
    /// The right to invoke `fd_seek` in such a way that the
    /// file offset remains unaltered (i.e., `whence.cur` with
    /// offset zero).
    const FD_TELL               = 0x0000000000000020;
    /// The right to invoke `fd_write` and `sock_send`.
    ///
    /// If `rights.mem_map` is set, includes the right to
    /// invoke `mem_map` with memory protection option
    /// `mprot.write`.
    ///
    /// If `rights.fd_seek` is set, includes the right to
    /// invoke `fd_pwrite`.
    const FD_WRITE              = 0x0000000000000040;
    /// The right to invoke `file_advise`.
    const FILE_ADVISE           = 0x0000000000000080;
    /// The right to invoke `file_allocate`.
    const FILE_ALLOCATE         = 0x0000000000000100;
    /// The right to invoke `file_create` with
    /// `filetype.directory`.
    const FILE_CREATE_DIRECTORY = 0x0000000000000200;
    /// If `rights.file_open` is set, the right to invoke
    /// `file_open` with `oflags.creat`.
    const FILE_CREATE_FILE      = 0x0000000000000400;
    /// The right to invoke `file_link` with the file
    /// descriptor as the source directory.
    const FILE_LINK_SOURCE      = 0x0000000000001000;
    /// The right to invoke `file_link` with the file
    /// descriptor as the target directory.
    const FILE_LINK_TARGET      = 0x0000000000002000;
    /// The right to invoke `file_open`.
    const FILE_OPEN             = 0x0000000000004000;
    /// The right to invoke `file_readdir`.
    const FILE_READDIR          = 0x0000000000008000;
    /// The right to invoke `file_readlink`.
    const FILE_READLINK         = 0x0000000000010000;
    /// The right to invoke `file_rename` with the file
    /// descriptor as the source directory.
    const FILE_RENAME_SOURCE    = 0x0000000000020000;
    /// The right to invoke `file_rename` with the file
    /// descriptor as the target directory.
    const FILE_RENAME_TARGET    = 0x0000000000040000;
    /// The right to invoke `file_stat_fget`.
    const FILE_STAT_FGET        = 0x0000000000080000;
    /// The right to invoke `file_stat_fput` with
    /// `fsflags.size`.
    ///
    /// If `rights.file_open` is set, includes the right to
    /// invoke `file_open` with `oflags.trunc`.
    const FILE_STAT_FPUT_SIZE   = 0x0000000000100000;
    /// The right to invoke `file_stat_fput` with
    /// `fsflags.atim`, `fsflags.atim_now`, `fsflags.mtim`,
    /// and `fsflags.mtim_now`.
    const FILE_STAT_FPUT_TIMES  = 0x0000000000200000;
    /// The right to invoke `file_stat_get`.
    const FILE_STAT_GET         = 0x0000000000400000;
    /// The right to invoke `file_stat_put` with
    /// `fsflags.atim`, `fsflags.atim_now`, `fsflags.mtim`,
    /// and `fsflags.mtim_now`.
    const FILE_STAT_PUT_TIMES   = 0x0000000000800000;
    /// The right to invoke `file_symlink`.
    const FILE_SYMLINK          = 0x0000000001000000;
    /// The right to invoke `file_unlink`.
    const FILE_UNLINK           = 0x0000000002000000;
    /// The right to invoke `mem_map` with `mprot` set to
    /// zero.
    const MEM_MAP               = 0x0000000004000000;
    /// If `rights.mem_map` is set, the right to invoke
    /// `mem_map` with `mprot.exec`.
    const MEM_MAP_EXEC          = 0x0000000008000000;
    /// If `rights.fd_read` is set, includes the right to
    /// invoke `poll` to subscribe to `eventtype.fd_read`.
    ///
    /// If `rights.fd_write` is set, includes the right to
    /// invoke `poll` to subscribe to `eventtype.fd_write`.
    const POLL_FD_READWRITE     = 0x0000000010000000;
    /// The right to invoke `poll` to subscribe to
    /// `eventtype.proc_terminate`.
    const POLL_PROC_TERMINATE   = 0x0000000040000000;
    /// The right to invoke `proc_exec`.
    const PROC_EXEC             = 0x0000000100000000;
    /// The right to invoke `sock_shutdown`.
    const SOCK_SHUTDOWN         = 0x0000008000000000;
  }
}

bitflags! {
  /// Flags returned by `sock_recv`.
  pub struct roflags: u16 {
    /// Returned by `sock_recv`: List of file descriptors
    /// has been truncated.
    const FDS_TRUNCATED  = 0x0001;
    /// Returned by `sock_recv`: Message data has been
    /// truncated.
    const DATA_TRUNCATED = 0x0008;
  }
}

/// Indicates whether an object is stored in private or shared
/// memory.
#[repr(u8)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub enum scope {
  /// The object is stored in private memory.
  PRIVATE = 4,
  /// The object is stored in shared memory.
  SHARED  = 8,
  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,
}

bitflags! {
  /// Which channels on a socket need to be shut down.
  pub struct sdflags: u8 {
    /// Disables further receive operations.
    const RD = 0x01;
    /// Disables further send operations.
    const WR = 0x02;
  }
}

bitflags! {
  /// Flags provided to `sock_send`. As there are currently no flags
  /// defined, it must be set to zero.
  pub struct siflags: u16 {
    const DEFAULT = 0;
  }
}

/// Signal condition.
#[repr(u8)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub enum signal {
  /// Process abort signal.
  ///
  /// Action: Terminates the process.
  ABRT   =  1,
  /// Alarm clock.
  ///
  /// Action: Terminates the process.
  ALRM   =  2,
  /// Access to an undefined portion of a memory object.
  ///
  /// Action: Terminates the process.
  BUS    =  3,
  /// Child process terminated, stopped, or continued.
  ///
  /// Action: Ignored.
  CHLD   =  4,
  /// Continue executing, if stopped.
  ///
  /// Action: Continues executing, if stopped.
  CONT   =  5,
  /// Erroneous arithmetic operation.
  ///
  /// Action: Terminates the process.
  FPE    =  6,
  /// Hangup.
  ///
  /// Action: Terminates the process.
  HUP    =  7,
  /// Illegal instruction.
  ///
  /// Action: Terminates the process.
  ILL    =  8,
  /// Terminate interrupt signal.
  ///
  /// Action: Terminates the process.
  INT    =  9,
  /// Kill.
  ///
  /// Action: Terminates the process.
  KILL   = 10,
  /// Write on a pipe with no one to read it.
  ///
  /// Action: Ignored.
  PIPE   = 11,
  /// Terminal quit signal.
  ///
  /// Action: Terminates the process.
  QUIT   = 12,
  /// Invalid memory reference.
  ///
  /// Action: Terminates the process.
  SEGV   = 13,
  /// Stop executing.
  ///
  /// Action: Stops executing.
  STOP   = 14,
  /// Bad system call.
  ///
  /// Action: Terminates the process.
  SYS    = 15,
  /// Termination signal.
  ///
  /// Action: Terminates the process.
  TERM   = 16,
  /// Trace/breakpoint trap.
  ///
  /// Action: Terminates the process.
  TRAP   = 17,
  /// Terminal stop signal.
  ///
  /// Action: Stops executing.
  TSTP   = 18,
  /// Background process attempting read.
  ///
  /// Action: Stops executing.
  TTIN   = 19,
  /// Background process attempting write.
  ///
  /// Action: Stops executing.
  TTOU   = 20,
  /// High bandwidth data is available at a socket.
  ///
  /// Action: Ignored.
  URG    = 21,
  /// User-defined signal 1.
  ///
  /// Action: Terminates the process.
  USR1   = 22,
  /// User-defined signal 2.
  ///
  /// Action: Terminates the process.
  USR2   = 23,
  /// Virtual timer expired.
  ///
  /// Action: Terminates the process.
  VTALRM = 24,
  /// CPU time limit exceeded.
  ///
  /// Action: Terminates the process.
  XCPU   = 25,
  /// File size limit exceeded.
  ///
  /// Action: Terminates the process.
  XFSZ   = 26,
  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,
}

bitflags! {
  /// Flags determining how the timestamp provided in
  /// `subscription.clock.timeout` should be interpreted.
  pub struct subclockflags: u16 {
    /// If set, treat the timestamp provided in
    /// `subscription.clock.timeout` as an absolute timestamp
    /// of clock `subscription.clock.clock_id`.
    ///
    /// If clear, treat the timestamp provided in
    /// `subscription.clock.timeout` relative to the current
    /// time value of clock `subscription.clock.clock_id`.
    const ABSTIME = 0x0001;
  }
}

bitflags! {
  /// Flags influencing the method of polling for read or writing on
  /// a file descriptor.
  pub struct subrwflags: u16 {
    /// Deprecated. Must be set by callers and ignored by
    /// implementations.
    const POLL = 0x0001;
  }
}

/// Unique system-local identifier of a thread. This identifier is
/// only valid during the lifetime of the thread.
///
/// Threads must be aware of their thread identifier, as it is
/// written it into locks when acquiring them for writing. It is
/// not advised to use these identifiers for any other purpose.
///
/// As the thread identifier is also stored in `lock` when
/// `lock.wrlocked` is set, the top two bits of the thread
/// must always be set to zero.
#[repr(C)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct tid(pub u32);

/// Timestamp in nanoseconds.
pub type timestamp = u64;

bitflags! {
  /// Specifies whether files are unlinked or directories are
  /// removed.
  pub struct ulflags: u8 {
    /// If set, removes a directory. Otherwise, unlinks any
    /// non-directory file.
    const REMOVEDIR = 0x01;
  }
}

/// User-provided value that can be attached to objects that is
/// retained when extracted from the kernel.
pub type userdata = u64;

/// Relative to which position the offset of the file descriptor
/// should be set.
#[repr(u8)]
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub enum whence {
  /// Seek relative to current position.
  CUR = 1,
  /// Seek relative to end-of-file.
  END = 2,
  /// Seek relative to start-of-file.
  SET = 3,
  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,
}

/// Auxiliary vector entry.
///
/// The auxiliary vector is a list of key-value pairs that is
/// provided to the process on startup. Unlike structures, it is
/// extensible, as it is possible to add new records later on.
/// The auxiliary vector is always terminated by an entry having
/// type `auxtype.null`.
///
/// The auxiliary vector is part of the x86-64 ABI, but is used by
/// this environment on all architectures.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct auxv {
  /// The type of the auxiliary vector entry.
  pub a_type: auxtype,
  pub union: auxv_union
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union auxv_union {
  pub a_val: usize,
  pub a_ptr: *mut (),
}

/// A region of memory for scatter/gather writes.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ciovec {
  /// The address and length of the buffer to be written.
  pub buf: (*const (), usize),
}

/// A directory entry.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
  /// The offset of the next directory entry stored in this
  /// directory.
  pub d_next: dircookie,
  /// The serial number of the file referred to by this
  /// directory entry.
  pub d_ino: inode,
  /// The length of the name of the directory entry.
  pub d_namlen: u32,
  /// The type of the file referred to by this directory
  /// entry.
  pub d_type: filetype,
}

/// An event that occurred.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event {
  /// User-provided value that got attached to
  /// `subscription.userdata`.
  pub userdata: userdata,
  /// If non-zero, an error that occurred while processing
  /// the subscription request.
  pub error: errno,
  /// The type of the event that occurred.
  pub type_: eventtype,
  pub union: event_union
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union event_union {
  pub fd_readwrite: event_fd_readwrite,
  pub proc_terminate: event_proc_terminate,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event_fd_readwrite {
  /// The number of bytes available
  /// for reading or writing.
  pub nbytes: filesize,
  /// Obsolete.
  pub unused: [u8; 4],
  /// The state of the file
  /// descriptor.
  pub flags: eventrwflags,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event_proc_terminate {
  /// Obsolete.
  pub unused: [u8; 4],
  /// If zero, the process has
  /// exited.
  /// Otherwise, the signal
  /// condition causing it to
  /// terminated.
  pub signal: signal,
  /// If exited, the exit code of
  /// the process.
  pub exitcode: exitcode,
}

/// File descriptor attributes.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fdstat {
  /// File type.
  pub fs_filetype: filetype,
  /// File descriptor flags.
  pub fs_flags: fdflags,
  /// Rights that apply to this file descriptor.
  pub fs_rights_base: rights,
  /// Maximum set of rights that can be installed on new
  /// file descriptors that are created through this file
  /// descriptor, e.g., through `file_open`.
  pub fs_rights_inheriting: rights,
}

/// File attributes.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct filestat {
  /// Device ID of device containing the file.
  pub st_dev: device,
  /// File serial number.
  pub st_ino: inode,
  /// File type.
  pub st_filetype: filetype,
  /// Number of hard links to the file.
  pub st_nlink: linkcount,
  /// For regular files, the file size in bytes. For
  /// symbolic links, the length in bytes of the pathname
  /// contained in the symbolic link.
  pub st_size: filesize,
  /// Last data access timestamp.
  pub st_atim: timestamp,
  /// Last data modification timestamp.
  pub st_mtim: timestamp,
  /// Last file status change timestamp.
  pub st_ctim: timestamp,
}

/// A region of memory for scatter/gather reads.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iovec {
  /// The address and length of the buffer to be filled.
  pub buf: (*mut (), usize),
}

/// Path lookup properties.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lookup {
  /// The working directory at which the resolution of the
  /// path starts.
  pub fd: fd,
  /// Flags determining the method of how the path is
  /// resolved.
  pub flags: lookupflags,
}

/// Entry point for a process (`_start`).
///
/// **auxv**:
/// The auxiliary vector. See `auxv`.
pub type processentry = extern "C" fn(
  auxv: *const auxv,
) -> ();

/// Arguments of `sock_recv`.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct recv_in {
  /// List of scatter/gather vectors where message data
  /// should be stored.
  pub ri_data: (*const iovec, usize),
  /// Buffer where numbers of incoming file descriptors
  /// should be stored.
  pub ri_fds: (*mut fd, usize),
  /// Message flags.
  pub ri_flags: riflags,
}

/// Results of `sock_recv`.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct recv_out {
  /// Number of bytes stored in `recv_in.ri_data`.
  pub ro_datalen: usize,
  /// Number of file descriptors stored in `recv_in.ri_fds`.
  pub ro_fdslen: usize,
  /// Fields that were used by previous implementations.
  pub ro_unused: [u8; 40],
  /// Message flags.
  pub ro_flags: roflags,
}

/// Arguments of `sock_send`.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct send_in {
  /// List of scatter/gather vectors where message data
  /// should be retrieved.
  pub si_data: (*const ciovec, usize),
  /// File descriptors that need to be attached to the
  /// message.
  pub si_fds: (*const fd, usize),
  /// Message flags.
  pub si_flags: siflags,
}

/// Results of `sock_send`.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct send_out {
  /// Number of bytes transmitted.
  pub so_datalen: usize,
}

/// Subscription to an event.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subscription {
  /// User-provided value that is attached to the
  /// subscription in the kernel and returned through
  /// `event.userdata`.
  pub userdata: userdata,
  /// Used by previous implementations. Ignored.
  pub unused: u16,
  /// The type of the event to which to subscribe.
  ///
  /// Currently, `eventtype.condvar`,
  /// `eventtype.lock_rdlock`, and `eventtype.lock_wrlock`
  /// must be provided as the first subscription and may
  /// only be followed by up to one other subscription,
  /// having type `eventtype.clock` with
  /// `subclockflags.abstime`.
  pub type_: eventtype,
  pub union: subscription_union
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union subscription_union {
  pub clock: subscription_clock,
  pub condvar: subscription_condvar,
  pub fd_readwrite: subscription_fd_readwrite,
  pub lock: subscription_lock,
  pub proc_terminate: subscription_proc_terminate,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subscription_clock {
  /// The user-defined unique
  /// identifier of the clock.
  pub identifier: userdata,
  /// The clock against which the
  /// timestamp should be compared.
  pub clock_id: clockid,
  /// The absolute or relative
  /// timestamp.
  pub timeout: timestamp,
  /// The amount of time that the
  /// kernel may wait additionally
  /// to coalesce with other events.
  pub precision: timestamp,
  /// Flags specifying whether the
  /// timeout is absolute or
  /// relative.
  pub flags: subclockflags,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subscription_condvar {
  /// The condition variable on
  /// which to wait to be woken up.
  pub condvar: *mut condvar,
  /// The lock that will be
  /// released while waiting.
  ///
  /// The lock will be reacquired
  /// for writing when the condition
  /// variable triggers.
  pub lock: *mut lock,
  /// Whether the condition variable
  /// is stored in private or shared
  /// memory.
  pub condvar_scope: scope,
  /// Whether the lock is stored in
  /// private or shared memory.
  pub lock_scope: scope,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subscription_fd_readwrite {
  /// The file descriptor on which
  /// to wait for it to become ready
  /// for reading or writing.
  pub fd: fd,
  /// Under which conditions to
  /// trigger.
  pub flags: subrwflags,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subscription_lock {
  /// The lock that will be acquired
  /// for reading or writing.
  pub lock: *mut lock,
  /// Whether the lock is stored in
  /// private or shared memory.
  pub lock_scope: scope,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subscription_proc_terminate {
  /// The process descriptor on
  /// which to wait for process
  /// termination.
  pub fd: fd,
}

/// The Thread Control Block (TCB).
///
/// After a thread begins execution (at program startup or when
/// created through `thread_create`), the CPU's registers
/// controlling Thread-Local Storage (TLS) will already be
/// initialized. They will point to an area only containing the
/// TCB.
///
/// If the thread needs space for storing thread-specific
/// variables, the thread may allocate a larger area and adjust
/// the CPU's registers to point to that area instead. However, it
/// does need to make sure that the TCB is copied over to the new
/// TLS area.
///
/// The purpose of the TCB is that it allows light-weight
/// emulators to store information related to individual threads.
/// For example, it may be used to store a copy of the CPU
/// registers prior emulation, so that TLS for the host system
/// can be restored if needed.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcb {
  /// Pointer that may be freely assigned by the system. Its
  /// value cannot be interpreted by the application.
  pub parent: *mut (),
}

/// Entry point for additionally created threads.
///
/// **tid**:
/// Thread ID of the current thread.
///
/// **aux**:
/// Copy of the value stored in
/// `threadattr.argument`.
pub type threadentry = extern "C" fn(
  tid: tid,
  aux: *mut (),
) -> ();

/// Attributes for thread creation.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct threadattr {
  /// Initial program counter value.
  pub entry_point: threadentry,
  /// Region allocated to serve as stack space.
  pub stack: (*mut (), usize),
  /// Argument to be forwarded to the entry point function.
  pub argument: *mut (),
}

