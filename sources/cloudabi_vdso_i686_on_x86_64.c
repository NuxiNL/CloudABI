// Copyright (c) 2016 Nuxi (https://nuxi.nl/) and contributors.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// This file is automatically generated. Do not edit.
//
// Source: https://github.com/NuxiNL/cloudabi

#include <cloudabi_types.h>

cloudabi_errno_t cloudabi_sys_clock_res_get(cloudabi_clockid_t clock_id,
                                            cloudabi_timestamp_t *resolution) {
  struct arguments {
    _Alignas(8) cloudabi_clockid_t clock_id;
  } arguments = {
      .clock_id = clock_id,
  };
  struct returns {
    _Alignas(8) cloudabi_timestamp_t resolution;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 0;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *resolution = returns.resolution;
  return 0;
}

cloudabi_errno_t cloudabi_sys_clock_time_get(cloudabi_clockid_t clock_id,
                                             cloudabi_timestamp_t precision,
                                             cloudabi_timestamp_t *time) {
  struct arguments {
    _Alignas(8) cloudabi_clockid_t clock_id;
    _Alignas(8) cloudabi_timestamp_t precision;
  } arguments = {
      .clock_id = clock_id, .precision = precision,
  };
  struct returns {
    _Alignas(8) cloudabi_timestamp_t time;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 1;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *time = returns.time;
  return 0;
}

cloudabi_errno_t cloudabi_sys_condvar_signal(_Atomic(cloudabi_condvar_t) *
                                                 condvar,
                                             cloudabi_scope_t scope,
                                             cloudabi_nthreads_t nwaiters) {
  struct arguments {
    _Alignas(8) uint64_t condvar;
    _Alignas(8) cloudabi_scope_t scope;
    _Alignas(8) cloudabi_nthreads_t nwaiters;
  } arguments = {
      .condvar = (uintptr_t)condvar, .scope = scope, .nwaiters = nwaiters,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 2;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_close(cloudabi_fd_t fd) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
  } arguments = {
      .fd = fd,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 3;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_create1(cloudabi_filetype_t type,
                                         cloudabi_fd_t *fd) {
  struct arguments {
    _Alignas(8) cloudabi_filetype_t type;
  } arguments = {
      .type = type,
  };
  struct returns {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 4;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *fd = returns.fd;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_create2(cloudabi_filetype_t type,
                                         cloudabi_fd_t *fd1,
                                         cloudabi_fd_t *fd2) {
  struct arguments {
    _Alignas(8) cloudabi_filetype_t type;
  } arguments = {
      .type = type,
  };
  struct returns {
    _Alignas(8) cloudabi_fd_t fd1;
    _Alignas(8) cloudabi_fd_t fd2;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 5;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *fd1 = returns.fd1;
  *fd2 = returns.fd2;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_datasync(cloudabi_fd_t fd) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
  } arguments = {
      .fd = fd,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 6;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_dup(cloudabi_fd_t from, cloudabi_fd_t *fd) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t from;
  } arguments = {
      .from = from,
  };
  struct returns {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 7;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *fd = returns.fd;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_pread(cloudabi_fd_t fd,
                                       const cloudabi_iovec_t *iov,
                                       size_t iovcnt,
                                       cloudabi_filesize_t offset,
                                       size_t *nread) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t iov;
    _Alignas(8) uint64_t iovcnt;
    _Alignas(8) cloudabi_filesize_t offset;
  } arguments = {
      .fd = fd, .iov = (uintptr_t)iov, .iovcnt = iovcnt, .offset = offset,
  };
  struct returns {
    _Alignas(8) size_t nread;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 8;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *nread = returns.nread;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_pwrite(cloudabi_fd_t fd,
                                        const cloudabi_ciovec_t *iov,
                                        size_t iovcnt,
                                        cloudabi_filesize_t offset,
                                        size_t *nwritten) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t iov;
    _Alignas(8) uint64_t iovcnt;
    _Alignas(8) cloudabi_filesize_t offset;
  } arguments = {
      .fd = fd, .iov = (uintptr_t)iov, .iovcnt = iovcnt, .offset = offset,
  };
  struct returns {
    _Alignas(8) size_t nwritten;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 9;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *nwritten = returns.nwritten;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_read(cloudabi_fd_t fd,
                                      const cloudabi_iovec_t *iov,
                                      size_t iovcnt, size_t *nread) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t iov;
    _Alignas(8) uint64_t iovcnt;
  } arguments = {
      .fd = fd, .iov = (uintptr_t)iov, .iovcnt = iovcnt,
  };
  struct returns {
    _Alignas(8) size_t nread;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 10;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *nread = returns.nread;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_replace(cloudabi_fd_t from, cloudabi_fd_t to) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t from;
    _Alignas(8) cloudabi_fd_t to;
  } arguments = {
      .from = from, .to = to,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 11;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_seek(cloudabi_fd_t fd,
                                      cloudabi_filedelta_t offset,
                                      cloudabi_whence_t whence,
                                      cloudabi_filesize_t *newoffset) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) cloudabi_filedelta_t offset;
    _Alignas(8) cloudabi_whence_t whence;
  } arguments = {
      .fd = fd, .offset = offset, .whence = whence,
  };
  struct returns {
    _Alignas(8) cloudabi_filesize_t newoffset;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 12;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *newoffset = returns.newoffset;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_stat_get(cloudabi_fd_t fd,
                                          cloudabi_fdstat_t *buf) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t buf;
  } arguments = {
      .fd = fd, .buf = (uintptr_t)buf,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 13;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_stat_put(cloudabi_fd_t fd,
                                          const cloudabi_fdstat_t *buf,
                                          cloudabi_fdsflags_t flags) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t buf;
    _Alignas(8) cloudabi_fdsflags_t flags;
  } arguments = {
      .fd = fd, .buf = (uintptr_t)buf, .flags = flags,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 14;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_sync(cloudabi_fd_t fd) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
  } arguments = {
      .fd = fd,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 15;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_fd_write(cloudabi_fd_t fd,
                                       const cloudabi_ciovec_t *iov,
                                       size_t iovcnt, size_t *nwritten) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t iov;
    _Alignas(8) uint64_t iovcnt;
  } arguments = {
      .fd = fd, .iov = (uintptr_t)iov, .iovcnt = iovcnt,
  };
  struct returns {
    _Alignas(8) size_t nwritten;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 16;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *nwritten = returns.nwritten;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_advise(cloudabi_fd_t fd,
                                          cloudabi_filesize_t offset,
                                          cloudabi_filesize_t len,
                                          cloudabi_advice_t advice) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) cloudabi_filesize_t offset;
    _Alignas(8) cloudabi_filesize_t len;
    _Alignas(8) cloudabi_advice_t advice;
  } arguments = {
      .fd = fd, .offset = offset, .len = len, .advice = advice,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 17;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_allocate(cloudabi_fd_t fd,
                                            cloudabi_filesize_t offset,
                                            cloudabi_filesize_t len) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) cloudabi_filesize_t offset;
    _Alignas(8) cloudabi_filesize_t len;
  } arguments = {
      .fd = fd, .offset = offset, .len = len,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 18;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_create(cloudabi_fd_t fd, const char *path,
                                          size_t pathlen,
                                          cloudabi_filetype_t type) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t path;
    _Alignas(8) uint64_t pathlen;
    _Alignas(8) cloudabi_filetype_t type;
  } arguments = {
      .fd = fd, .path = (uintptr_t)path, .pathlen = pathlen, .type = type,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 19;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_link(cloudabi_lookup_t fd1,
                                        const char *path1, size_t path1len,
                                        cloudabi_fd_t fd2, const char *path2,
                                        size_t path2len) {
  struct arguments {
    _Alignas(8) cloudabi_lookup_t fd1;
    _Alignas(8) uint64_t path1;
    _Alignas(8) uint64_t path1len;
    _Alignas(8) cloudabi_fd_t fd2;
    _Alignas(8) uint64_t path2;
    _Alignas(8) uint64_t path2len;
  } arguments = {
      .fd1 = fd1,
      .path1 = (uintptr_t)path1,
      .path1len = path1len,
      .fd2 = fd2,
      .path2 = (uintptr_t)path2,
      .path2len = path2len,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 20;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_open(cloudabi_lookup_t dirfd,
                                        const char *path, size_t pathlen,
                                        cloudabi_oflags_t oflags,
                                        const cloudabi_fdstat_t *fds,
                                        cloudabi_fd_t *fd) {
  struct arguments {
    _Alignas(8) cloudabi_lookup_t dirfd;
    _Alignas(8) uint64_t path;
    _Alignas(8) uint64_t pathlen;
    _Alignas(8) cloudabi_oflags_t oflags;
    _Alignas(8) uint64_t fds;
  } arguments = {
      .dirfd = dirfd,
      .path = (uintptr_t)path,
      .pathlen = pathlen,
      .oflags = oflags,
      .fds = (uintptr_t)fds,
  };
  struct returns {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 21;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *fd = returns.fd;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_readdir(cloudabi_fd_t fd, void *buf,
                                           size_t nbyte,
                                           cloudabi_dircookie_t cookie,
                                           size_t *bufused) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t buf;
    _Alignas(8) uint64_t nbyte;
    _Alignas(8) cloudabi_dircookie_t cookie;
  } arguments = {
      .fd = fd, .buf = (uintptr_t)buf, .nbyte = nbyte, .cookie = cookie,
  };
  struct returns {
    _Alignas(8) size_t bufused;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 22;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *bufused = returns.bufused;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_readlink(cloudabi_fd_t fd, const char *path,
                                            size_t pathlen, char *buf,
                                            size_t bufsize, size_t *bufused) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t path;
    _Alignas(8) uint64_t pathlen;
    _Alignas(8) uint64_t buf;
    _Alignas(8) uint64_t bufsize;
  } arguments = {
      .fd = fd,
      .path = (uintptr_t)path,
      .pathlen = pathlen,
      .buf = (uintptr_t)buf,
      .bufsize = bufsize,
  };
  struct returns {
    _Alignas(8) size_t bufused;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 23;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *bufused = returns.bufused;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_rename(cloudabi_fd_t oldfd, const char *old,
                                          size_t oldlen, cloudabi_fd_t newfd,
                                          const char *new, size_t newlen) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t oldfd;
    _Alignas(8) uint64_t old;
    _Alignas(8) uint64_t oldlen;
    _Alignas(8) cloudabi_fd_t newfd;
    _Alignas(8) uint64_t new;
    _Alignas(8) uint64_t newlen;
  } arguments = {
      .oldfd = oldfd,
      .old = (uintptr_t)old,
      .oldlen = oldlen,
      .newfd = newfd,
      .new = (uintptr_t) new,
      .newlen = newlen,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 24;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_stat_fget(cloudabi_fd_t fd,
                                             cloudabi_filestat_t *buf) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t buf;
  } arguments = {
      .fd = fd, .buf = (uintptr_t)buf,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 25;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_stat_fput(cloudabi_fd_t fd,
                                             const cloudabi_filestat_t *buf,
                                             cloudabi_fsflags_t flags) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t buf;
    _Alignas(8) cloudabi_fsflags_t flags;
  } arguments = {
      .fd = fd, .buf = (uintptr_t)buf, .flags = flags,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 26;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_stat_get(cloudabi_lookup_t fd,
                                            const char *path, size_t pathlen,
                                            cloudabi_filestat_t *buf) {
  struct arguments {
    _Alignas(8) cloudabi_lookup_t fd;
    _Alignas(8) uint64_t path;
    _Alignas(8) uint64_t pathlen;
    _Alignas(8) uint64_t buf;
  } arguments = {
      .fd = fd,
      .path = (uintptr_t)path,
      .pathlen = pathlen,
      .buf = (uintptr_t)buf,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 27;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_stat_put(cloudabi_lookup_t fd,
                                            const char *path, size_t pathlen,
                                            const cloudabi_filestat_t *buf,
                                            cloudabi_fsflags_t flags) {
  struct arguments {
    _Alignas(8) cloudabi_lookup_t fd;
    _Alignas(8) uint64_t path;
    _Alignas(8) uint64_t pathlen;
    _Alignas(8) uint64_t buf;
    _Alignas(8) cloudabi_fsflags_t flags;
  } arguments = {
      .fd = fd,
      .path = (uintptr_t)path,
      .pathlen = pathlen,
      .buf = (uintptr_t)buf,
      .flags = flags,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 28;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_symlink(const char *path1, size_t path1len,
                                           cloudabi_fd_t fd, const char *path2,
                                           size_t path2len) {
  struct arguments {
    _Alignas(8) uint64_t path1;
    _Alignas(8) uint64_t path1len;
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t path2;
    _Alignas(8) uint64_t path2len;
  } arguments = {
      .path1 = (uintptr_t)path1,
      .path1len = path1len,
      .fd = fd,
      .path2 = (uintptr_t)path2,
      .path2len = path2len,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 29;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_file_unlink(cloudabi_fd_t fd, const char *path,
                                          size_t pathlen,
                                          cloudabi_ulflags_t flags) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t path;
    _Alignas(8) uint64_t pathlen;
    _Alignas(8) cloudabi_ulflags_t flags;
  } arguments = {
      .fd = fd, .path = (uintptr_t)path, .pathlen = pathlen, .flags = flags,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 30;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_lock_unlock(_Atomic(cloudabi_lock_t) * lock,
                                          cloudabi_scope_t scope) {
  struct arguments {
    _Alignas(8) uint64_t lock;
    _Alignas(8) cloudabi_scope_t scope;
  } arguments = {
      .lock = (uintptr_t)lock, .scope = scope,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 31;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_mem_advise(void *addr, size_t len,
                                         cloudabi_advice_t advice) {
  struct arguments {
    _Alignas(8) uint64_t addr;
    _Alignas(8) uint64_t len;
    _Alignas(8) cloudabi_advice_t advice;
  } arguments = {
      .addr = (uintptr_t)addr, .len = len, .advice = advice,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 32;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_mem_lock(const void *addr, size_t len) {
  struct arguments {
    _Alignas(8) uint64_t addr;
    _Alignas(8) uint64_t len;
  } arguments = {
      .addr = (uintptr_t)addr, .len = len,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 33;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_mem_map(void *addr, size_t len,
                                      cloudabi_mprot_t prot,
                                      cloudabi_mflags_t flags, cloudabi_fd_t fd,
                                      cloudabi_filesize_t off, void **mem) {
  struct arguments {
    _Alignas(8) uint64_t addr;
    _Alignas(8) uint64_t len;
    _Alignas(8) cloudabi_mprot_t prot;
    _Alignas(8) cloudabi_mflags_t flags;
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) cloudabi_filesize_t off;
  } arguments = {
      .addr = (uintptr_t)addr,
      .len = len,
      .prot = prot,
      .flags = flags,
      .fd = fd,
      .off = off,
  };
  struct returns {
    _Alignas(8) void *mem;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 34;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *mem = returns.mem;
  return 0;
}

cloudabi_errno_t cloudabi_sys_mem_protect(void *addr, size_t len,
                                          cloudabi_mprot_t prot) {
  struct arguments {
    _Alignas(8) uint64_t addr;
    _Alignas(8) uint64_t len;
    _Alignas(8) cloudabi_mprot_t prot;
  } arguments = {
      .addr = (uintptr_t)addr, .len = len, .prot = prot,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 35;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_mem_sync(void *addr, size_t len,
                                       cloudabi_msflags_t flags) {
  struct arguments {
    _Alignas(8) uint64_t addr;
    _Alignas(8) uint64_t len;
    _Alignas(8) cloudabi_msflags_t flags;
  } arguments = {
      .addr = (uintptr_t)addr, .len = len, .flags = flags,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 36;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_mem_unlock(const void *addr, size_t len) {
  struct arguments {
    _Alignas(8) uint64_t addr;
    _Alignas(8) uint64_t len;
  } arguments = {
      .addr = (uintptr_t)addr, .len = len,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 37;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_mem_unmap(void *addr, size_t len) {
  struct arguments {
    _Alignas(8) uint64_t addr;
    _Alignas(8) uint64_t len;
  } arguments = {
      .addr = (uintptr_t)addr, .len = len,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 38;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_poll(const cloudabi_subscription_t *in,
                                   cloudabi_event_t *out, size_t nsubscriptions,
                                   size_t *nevents) {
  struct arguments {
    _Alignas(8) uint64_t in;
    _Alignas(8) uint64_t out;
    _Alignas(8) uint64_t nsubscriptions;
  } arguments = {
      .in = (uintptr_t)in,
      .out = (uintptr_t)out,
      .nsubscriptions = nsubscriptions,
  };
  struct returns {
    _Alignas(8) size_t nevents;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 39;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *nevents = returns.nevents;
  return 0;
}

cloudabi_errno_t cloudabi_sys_poll_fd(cloudabi_fd_t fd,
                                      const cloudabi_subscription_t *in,
                                      size_t nin, cloudabi_event_t *out,
                                      size_t nout,
                                      const cloudabi_subscription_t *timeout,
                                      size_t *nevents) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t in;
    _Alignas(8) uint64_t nin;
    _Alignas(8) uint64_t out;
    _Alignas(8) uint64_t nout;
    _Alignas(8) uint64_t timeout;
  } arguments = {
      .fd = fd,
      .in = (uintptr_t)in,
      .nin = nin,
      .out = (uintptr_t)out,
      .nout = nout,
      .timeout = (uintptr_t)timeout,
  };
  struct returns {
    _Alignas(8) size_t nevents;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 40;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *nevents = returns.nevents;
  return 0;
}

cloudabi_errno_t cloudabi_sys_proc_exec(cloudabi_fd_t fd, const void *data,
                                        size_t datalen,
                                        const cloudabi_fd_t *fds,
                                        size_t fdslen) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t data;
    _Alignas(8) uint64_t datalen;
    _Alignas(8) uint64_t fds;
    _Alignas(8) uint64_t fdslen;
  } arguments = {
      .fd = fd,
      .data = (uintptr_t)data,
      .datalen = datalen,
      .fds = (uintptr_t)fds,
      .fdslen = fdslen,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 41;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

_Noreturn void cloudabi_sys_proc_exit(cloudabi_exitcode_t rval) {
  struct arguments {
    _Alignas(8) cloudabi_exitcode_t rval;
  } arguments = {
      .rval = rval,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 42;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  for (;;)
    ;
}

cloudabi_errno_t cloudabi_sys_proc_fork(cloudabi_fd_t *fd,
                                        cloudabi_tid_t *tid) {
  struct returns {
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) cloudabi_tid_t tid;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 43;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *fd = returns.fd;
  *tid = returns.tid;
  return 0;
}

cloudabi_errno_t cloudabi_sys_proc_raise(cloudabi_signal_t sig) {
  struct arguments {
    _Alignas(8) cloudabi_signal_t sig;
  } arguments = {
      .sig = sig,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 44;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_random_get(void *buf, size_t nbyte) {
  struct arguments {
    _Alignas(8) uint64_t buf;
    _Alignas(8) uint64_t nbyte;
  } arguments = {
      .buf = (uintptr_t)buf, .nbyte = nbyte,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 45;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_sock_accept(cloudabi_fd_t sock,
                                          cloudabi_sockstat_t *buf,
                                          cloudabi_fd_t *conn) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t sock;
    _Alignas(8) uint64_t buf;
  } arguments = {
      .sock = sock, .buf = (uintptr_t)buf,
  };
  struct returns {
    _Alignas(8) cloudabi_fd_t conn;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 46;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *conn = returns.conn;
  return 0;
}

cloudabi_errno_t cloudabi_sys_sock_bind(cloudabi_fd_t sock, cloudabi_fd_t fd,
                                        const char *path, size_t pathlen) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t sock;
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t path;
    _Alignas(8) uint64_t pathlen;
  } arguments = {
      .sock = sock, .fd = fd, .path = (uintptr_t)path, .pathlen = pathlen,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 47;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_sock_connect(cloudabi_fd_t sock, cloudabi_fd_t fd,
                                           const char *path, size_t pathlen) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t sock;
    _Alignas(8) cloudabi_fd_t fd;
    _Alignas(8) uint64_t path;
    _Alignas(8) uint64_t pathlen;
  } arguments = {
      .sock = sock, .fd = fd, .path = (uintptr_t)path, .pathlen = pathlen,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 48;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_sock_listen(cloudabi_fd_t sock,
                                          cloudabi_backlog_t backlog) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t sock;
    _Alignas(8) cloudabi_backlog_t backlog;
  } arguments = {
      .sock = sock, .backlog = backlog,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 49;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_sock_recv(cloudabi_fd_t sock,
                                        const cloudabi_recv_in_t *in,
                                        cloudabi_recv_out_t *out) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t sock;
    _Alignas(8) uint64_t in;
    _Alignas(8) uint64_t out;
  } arguments = {
      .sock = sock, .in = (uintptr_t)in, .out = (uintptr_t)out,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 50;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_sock_send(cloudabi_fd_t sock,
                                        const cloudabi_send_in_t *in,
                                        cloudabi_send_out_t *out) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t sock;
    _Alignas(8) uint64_t in;
    _Alignas(8) uint64_t out;
  } arguments = {
      .sock = sock, .in = (uintptr_t)in, .out = (uintptr_t)out,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 51;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_sock_shutdown(cloudabi_fd_t sock,
                                            cloudabi_sdflags_t how) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t sock;
    _Alignas(8) cloudabi_sdflags_t how;
  } arguments = {
      .sock = sock, .how = how,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 52;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_sock_stat_get(cloudabi_fd_t sock,
                                            cloudabi_sockstat_t *buf,
                                            cloudabi_ssflags_t flags) {
  struct arguments {
    _Alignas(8) cloudabi_fd_t sock;
    _Alignas(8) uint64_t buf;
    _Alignas(8) cloudabi_ssflags_t flags;
  } arguments = {
      .sock = sock, .buf = (uintptr_t)buf, .flags = flags,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 53;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}

cloudabi_errno_t cloudabi_sys_thread_create(cloudabi_threadattr_t *attr,
                                            cloudabi_tid_t *tid) {
  struct arguments {
    _Alignas(8) uint64_t attr;
  } arguments = {
      .attr = (uintptr_t)attr,
  };
  struct returns {
    _Alignas(8) cloudabi_tid_t tid;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 54;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  *tid = returns.tid;
  return 0;
}

_Noreturn void cloudabi_sys_thread_exit(_Atomic(cloudabi_lock_t) * lock,
                                        cloudabi_scope_t scope) {
  struct arguments {
    _Alignas(8) uint64_t lock;
    _Alignas(8) cloudabi_scope_t scope;
  } arguments = {
      .lock = (uintptr_t)lock, .scope = scope,
  };
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 55;
  register struct arguments *reg_ebx asm("ebx") = &arguments;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ebx), "r"(reg_ecx)
               : "memory");
  for (;;)
    ;
}

cloudabi_errno_t cloudabi_sys_thread_yield(void) {
  struct returns {
    _Alignas(8) char unused0;
    _Alignas(8) char unused1;
  } returns;
  _Static_assert(sizeof(returns) == 16, "Size mismatch");
  register uint32_t reg_eax asm("eax") = 56;
  register struct returns *reg_ecx asm("ecx") = &returns;
  asm volatile("\tint $0x80\n"
               : "=r"(reg_eax)
               : "r"(reg_eax), "r"(reg_ecx)
               : "memory");
  if (reg_eax != 0)
    return reg_eax;
  return 0;
}
